# Sonic JIT x86 vs ARM64 架构对比详解

## 1. 寄存器映射对比

### 1.1 x86-64 寄存器布局
```
通用寄存器 (16个):
    RAX  - 返回值/临时寄存器
    RBX  - 栈基址 (callee-saved)
    RCX  - 第4个参数/临时寄存器
    RDX  - 第3个参数/返回值(高位)/临时寄存器
    RSI  - 第2个参数/源地址寄存器
    RDI  - 第1个参数/目标地址寄存器
    RBP  - 帧指针 (callee-saved)
    RSP  - 栈指针

    R8-R15 - 第5-8个参数/临时寄存器 (R12-R15为callee-saved)

Sonic专用寄存器分配:
    RBX  - stack base (栈基址)
    RDI  - result pointer (结果指针)
    RSI  - result length (结果长度)
    RDX  - result capacity (结果容量)
    R12  - sp->p (栈指针->p)
    R13  - sp->q (栈指针->q)
    R14  - sp->x (栈指针->x)
    R15  - sp->f (栈指针->f)
    R10  - error type register (错误类型寄存器)
    R11  - error pointer register (错误指针寄存器)
```

### 1.2 ARM64 寄存器布局
```
通用寄存器 (31个):
    X0-X7  - 参数/返回值寄存器 (caller-saved)
    X8-X15 - 临时寄存器 (caller-saved)
    X16-X17 - 过程内调用临时寄存器 (caller-saved)
    X18    - 平台寄存器 (callee-saved)
    X19-X28 - 被调用者保存寄存器 (callee-saved)
    X29(FP) - 帧指针 (callee-saved)
    X30(LR) - 链接寄存器 (caller-saved)
    X31(SP) - 栈指针
    XZR    - 零寄存器 (只读)

Sonic专用寄存器分配:
    X19  - stack base (栈基址)
    X20  - result pointer (结果指针)
    X21  - result length (结果长度)
    X22  - result capacity (结果容量)
    X23  - sp->p (栈指针->p)
    X24  - sp->q (栈指针->q)
    X25  - sp->x (栈指针->x)
    X26  - sp->f (栈指针->f)
    X27  - error type register (错误类型寄存器)
    X28  - error pointer register (错误指针寄存器)
```

## 2. 调用约定对比

### 2.1 x86-64 System V AMD64 ABI
```go
// 函数原型
func (buf *[]byte, p unsafe.Pointer, sb *_Stack, fv uint64) (err error)

// 参数传递
buf    -> RDI
p      -> RSI
sb     -> RDX
fv     -> RCX
err.vt -> R8  (返回值低位)
err.vp -> R9  (返回值高位)

// 栈帧布局 (16字节对齐)
[FP]      <- 返回地址
[FP-8]    <- 被保存的RBX
[FP-16]   <- 被保存的RBP
[FP-24]   <- 局部变量1
[FP-32]   <- 局部变量2
[FP-40]   <- spill区域
```

### 2.2 ARM64 Procedure Call Standard
```go
// 函数原型
func (buf *[]byte, p unsafe.Pointer, sb *_Stack, fv uint64) (err error)

// 参数传递
buf    -> X0
p      -> X1
sb     -> X2
fv     -> X3
err.vt -> X0 (返回值低位)
err.vp -> X1 (返回值高位)

// 栈帧布局 (16字节对齐)
[FP]      <- 被保存的FP (X29)
[FP-8]    <- 被保存的LR (X30)
[FP-16]   <- 局部变量1
[FP-24]   <- 局部变量2
[FP-32]   <- spill区域
```

## 3. 指令集对比

### 3.1 基本数据操作对比

| 操作 | x86-64 | ARM64 | 说明 |
|------|--------|-------|------|
| 数据移动 | `MOV` | `MOVD` | 寄存器间数据传输 |
| 立即数加载 | `MOV $imm, reg` | `MOVD $imm, reg` | 立即数到寄存器 |
| 内存加载 | `MOV [addr], reg` | `MOVD [addr], reg` | 内存到寄存器 |
| 内存存储 | `MOV reg, [addr]` | `MOVD reg, [addr]` | 寄存器到内存 |
| 加法 | `ADD` | `ADD` | 算术加法 |
| 减法 | `SUB` | `SUB` | 算术减法 |
| 比较 | `CMP` | `CMP` | 比较操作 |
| 跳转 | `JMP/Jcc` | `B/B.cc` | 无条件/条件跳转 |

### 3.2 特殊指令对比

| 功能 | x86-64 | ARM64 | 性能特点 |
|------|--------|-------|----------|
| 16字节移动 | `MOVDQA` | `LDP/STP` | ARM64寄存器对操作更高效 |
| 字符串操作 | `MOVSQ/MOVSB` | `LDR/STR` | ARM64需要手动循环 |
| 零扩展 | `MOVZX` | `UXTH/UXTW` | 功能相同 |
| 符号扩展 | `MOVSX` | `SXTH/SXTW` | 功能相同 |
| 位操作 | `BT/BSR/BSL` | `TST/BFI` | ARM64位操作更丰富 |

## 4. 栈帧管理对比

### 4.1 x86-64 栈帧结构
```assembly
; 函数序言
push    rbp                ; 保存旧帧指针
mov     rbp, rsp            ; 设置新帧指针
sub     rsp, FRAME_SIZE     ; 分配栈空间

; 局部变量访问
mov     rax, [rbp-8]       ; 访问局部变量1
mov     rbx, [rbp-16]      ; 访问局部变量2

; 函数尾声
mov     rsp, rbp            ; 恢复栈指针
pop     rbp                ; 恢复旧帧指针
ret                        ; 返回
```

### 4.2 ARM64 栈帧结构
```assembly
; 函数序言
stp     x29, x30, [sp, #-16]! ; 保存FP和LR，分配16字节
mov     x29, sp              ; 设置新帧指针
sub     sp, sp, FRAME_SIZE   ; 分配栈空间

; 局部变量访问
ldr     x0, [x29, #-8]       ; 访问局部变量1
ldr     x1, [x29, #-16]      ; 访问局部变量2

; 函数尾声
add     sp, sp, FRAME_SIZE   ; 释放栈空间
ldp     x29, x30, [sp], #16  ; 恢复FP和LR，释放16字节
ret                          ; 返回
```

## 5. JIT编译实现对比

### 5.1 x86-64 汇编器实现
```go
// 基本指令生成
func (self *Assembler) _asm_OP_bool(p *ir.Instr) {
    self.Emit("CMPB", jit.Ptr(_SP_p, 0), jit.Imm(0))
    self.Sjmp("JE", "_false_{n}")
    self.Emit("MOVD", jit.Imm(_IM_true), _RT)
    self.Emit("MOVD", _RT, jit.Ptr(_RP, 0))
    self.Emit("ADD", _RL, jit.Imm(4))
    self.Sjmp("JMP", "_end_{n}")
    self.Link("_false_{n}")
    self.Emit("MOVD", jit.Imm(_IM_fals), _RT)
    self.Emit("MOVD", _RT, jit.Ptr(_RP, 0))
    self.Emit("ADD", _RL, jit.Imm(5))
    self.Link("_end_{n}")
}
```

### 5.2 ARM64 汇编器实现
```go
// 对应的ARM64实现
func (self *Assembler) _asm_OP_bool(p *ir.Instr) {
    self.Emit("CMPB", jit.Ptr(_SP_p, 0), jit.Imm(0))
    self.Sjmp("B.EQ", "_false_{n}")
    self.Emit("MOVW", jit.Imm(_IM_true), _TEMP0)
    self.Emit("MOVWU", _TEMP0, jit.Ptr(_RP, 0))
    self.Emit("ADD", _RL, jit.Imm(4))
    self.Sjmp("B", "_end_{n}")
    self.Link("_false_{n}")
    self.Emit("MOVW", jit.Imm(_IM_fals), _TEMP0)
    self.Emit("MOVWU", _TEMP0, jit.Ptr(_RP, 0))
    self.Emit("ADD", _RL, jit.Imm(5))
    self.Link("_end_{n}")
}
```

## 6. 性能优化对比

### 6.1 内存访问优化

#### x86-64 优化
```go
// 使用SIMD指令批量处理
func (self *Assembler) add_text_fast(s string) {
    if len(s) >= 16 {
        self.Emit("MOVOU", jit.Imm(rt.Get128(s)), _XMM0)
        self.Emit("MOVOU", _XMM0, jit.Ptr(_RP, 0))
        self.Emit("ADD", _RL, jit.Imm(16))
    }
}
```

#### ARM64 优化
```go
// 使用寄存器对批量处理
func (self *Assembler) add_text_fast(s string) {
    if len(s) >= 16 {
        self.Emit("LDP", jit.Imm(rt.Get64(s)), _TEMP0, _TEMP1)
        self.Emit("STP", _TEMP0, _TEMP1, jit.Ptr(_RP, 0))
        self.Emit("ADD", _RL, jit.Imm(16))
    }
}
```

### 6.2 数字编码优化

#### x86-64 数字编码
```go
// 使用LEA指令进行快速乘法
func (self *Assembler) _asm_OP_u64(p *ir.Instr) {
    self.check_size(20)
    self.Emit("LEAQ", jit.Ptr(_SP_p, 0), _ARG0)  ; LEA作为乘法优化
    self.call_c(_F_u64toa)
    self.Emit("ADD", _RL, _ARG0)
}
```

#### ARM64 数字编码
```go
// 使用MADD指令进行乘加运算
func (self *Assembler) _asm_OP_u64(p *ir.Instr) {
    self.check_size(20)
    self.Emit("MOVD", jit.Ptr(_SP_p, 0), _ARG0)
    self.call_c(_F_u64toa)
    self.Emit("ADD", _RL, _ARG0)
}
```

## 7. 错误处理对比

### 7.1 x86-64 错误处理
```go
func (self *Assembler) epilogue() {
    self.Link("_error")

    // 错误处理路径
    self.Emit("MOVQ", _ET, jit.Ptr(_SP, _FP_err_vt))
    self.Emit("MOVQ", _EP, jit.Ptr(_SP, _FP_err_vp))

    // 清理和返回
    self.Emit("MOVQ", jit.Ptr(_ARG_rb, 8), _RSI)
    self.Emit("MOVQ", _RSI, jit.Ptr(_ARG_rb, 8))
    self.Emit("MOVQ", _R0, _ARG_rb)
    self.Emit("MOVQ", _R0, _ARG_vp)
    self.Emit("MOVQ", _R0, _ARG_sb)

    self.Emit("MOVQ", jit.Ptr(_SP, FP_offs), _RBP)
    self.Emit("ADDQ", jit.Imm(_FP_size), _RSP)
    self.Emit("RET")
}
```

### 7.2 ARM64 错误处理
```go
func (self *Assembler) epilogue() {
    self.Link("_error")

    // 错误处理路径
    self.Emit("MOVD", _ET, jit.Ptr(_SP, _FP_err_vt))
    self.Emit("MOVD", _EP, jit.Ptr(_SP, _FP_err_vp))

    // 清理和返回
    self.Emit("MOVD", jit.Ptr(_ARG_rb, 8), _TEMP1)
    self.Emit("MOVD", _TEMP1, jit.Ptr(_ARG_rb, 8))
    self.Emit("MOVD", _ZR, _ARG_rb)
    self.Emit("MOVD", _ZR, _ARG_vp)
    self.Emit("MOVD", _ZR, _ARG_sb)

    self.Emit("MOVD", jit.Ptr(_SP, FP_offs), _FP_REG)
    self.Emit("ADD", _SP, _SP, jit.Imm(_FP_size))
    self.Emit("RET")
}
```

## 8. 总结

### 8.1 架构优势对比

**x86-64 优势:**
- 丰富的SIMD指令集 (AVX2, AVX-512)
- 成熟的编译器优化技术
- 复杂地址模式支持
- 变长指令集，代码密度高

**ARM64 优势:**
- 更多的通用寄存器 (31 vs 16)
- 固定长度指令，解码简单
- 清晰的寄存器使用约定
- 更好的功耗效率

### 8.2 Sonic JIT 适配要点

1. **寄存器分配**: ARM64有更多寄存器，可以减少内存访问
2. **指令选择**: ARM64需要使用不同的指令集
3. **栈帧管理**: 两种架构的栈帧布局不同
4. **调用约定**: 参数传递和返回值处理方式不同
5. **错误处理**: 寄存器保存和恢复策略不同

通过这种详细的对比分析，我们可以看到虽然两种架构在底层实现上有很大差异，但Sonic的JIT框架能够很好地适配这两种架构，实现跨平台的高性能JSON编码。